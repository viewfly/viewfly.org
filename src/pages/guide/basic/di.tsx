import { inject, useRef } from '@viewfly/core'
import { ViewUpdateInjectionToken } from '../injection-tokens'
export default function() {
  const subject = inject(ViewUpdateInjectionToken)
  const ref = useRef(node => {
    subject.next(node as HTMLElement)
  })
  return function() {
    return (
      <div ref={ref}><h1>依赖注入</h1>
<p>依赖注入是 IoC（Inversion of Control）控制反转技术的一种实现，是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度，Viewfly 通过集成&nbsp;<a target="_blank" href="https://github.com/tbhuabi/di">@tanbo/di</a>&nbsp;实现了类似 Angular 一样的控制反转能力。</p>
<p>要完整使用 Viewfly 提供的依赖注入能力，需要 TypeScript 的支持，并且要在 tsconfig 中开启如下配置，并且确保你的编译器可以正确编辑装装饰器。</p><pre lang="JSON" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-attr-name">"compilerOptions"</span>: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-attr-name">"emitDecoratorMetadata"</span>:&nbsp;<span class="tb-hl-boolean">true</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-attr-name">"experimentalDecorators"</span>:&nbsp;<span class="tb-hl-boolean">true</span>,</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">JSON</span></div></pre>
<p>同时，你还需要安装 reflect-metadata 这个元数据兼容库，并在应用入口处导入它。</p><pre lang="" theme="starry" class="tb-pre tb-pre-hide-line-number"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">npm install reflect-metadata</div></div><span class="tb-pre-lang"></span></div></pre><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;<span class="tb-hl-string">'reflect-metadata'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} createApp {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/platform-browser'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">createApp</span>(&lt;App/&gt;).<span class="tb-hl-function">mount</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'app'</span>))</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>当然，如果你不想使用装饰器，我们也可以完全通过其它方式实现类似 Vue 的 provide/inject 或 React 的 Context 的效果。</p>
<h2>基本使用</h2>
<p>Viewfly 提供了 provide 和 inject 两个函数，用于在组件渲染上下文中实现跨组件通讯能力。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} inject, provide, InjectionToken {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;UserToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>(<span class="tb-hl-string">'UserToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;user =&nbsp;<span class="tb-hl-function">inject</span>(UserToken)</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(user.name)&nbsp;<span class="tb-hl-comment">// 张三</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;{'{'}user.name{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: UserToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'张三'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>在上面的示例中，我们通过在上层组件通过 provide 函数提供了一个 UserToken，在下层组件使用 inject 函数获取 UserToken，即获取到上层组件提供的数据。</p>
<p>我们看到在调用 &nbsp;provide 函数时，我们传入了一个对象，对象有 provide 和 useValue 两个属性。我们可以简单把 provide 属性的值作为 key，把 useValue 属性的值作为 value。</p>
<p>要注意的是，provide 的值必须为一个 InjectionToken 的实例。这在 JavaScript 编写中并没有太大意义，但在 TypeScript 场景中，它将为我们提供准确的类型提示能力，我们将上面的示例改为 TypeScript。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} inject, provide, InjectionToken {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">interface</span>&nbsp;<span class="tb-hl-class-name">User</span>&nbsp;{'{'}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-builtin">string</span></div><div class="tb-code-line-emphasize tb-code-line">{'}'}</div><div class="tb-code-line-emphasize tb-code-line"><br/></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;UserToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>&lt;<span class="tb-hl-class-name">User</span>&gt;(<span class="tb-hl-string">'UserToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;user =&nbsp;<span class="tb-hl-function">inject</span>(UserToken)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(user.name)&nbsp;<span class="tb-hl-comment">// 张三</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;p&gt;{'{'}user.name{'}'}&lt;/p&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: UserToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'张三'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>现在，如果我们在子组件尝试访问 user.age 时，你将会发现，TypeScript 将会抛出错误信息。</p>
<tb-alert data-type="info" class="tb-alert tb-alert-info">
  <div>Viewfly 的依赖注入实现，基本和 Angular 类似，如果你有 Angular 的使用经验，你完全可以照搬原来的经验。当然，没有也没关系，Viewfly 的依赖注入 API 简单多了</div>
</tb-alert>
<h2>Injectable()</h2>
<p>常见的依赖注入，往往是基于 Class 的，我们可以通过 Injectable 装饰器，把一个类标记为可注入的，即可使用 Viewfly 自动管理依赖和自动实例化的能力。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, provide, inject {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// 声明类是可注入的</span></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">ChildService</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name =&nbsp;<span class="tb-hl-string">'child'</span></div><div class="tb-code-line">&nbsp;&nbsp;index:&nbsp;<span class="tb-hl-builtin">number</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>() {'{'}{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// 声明类是可注入的</span></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">ParentSerivce</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name =&nbsp;<span class="tb-hl-string">'parent'</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(<span class="tb-hl-keyword">public</span>&nbsp;child: ChildService) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;parentService =&nbsp;<span class="tb-hl-function">inject</span>(ParentSerivce)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(parentService.name)&nbsp;<span class="tb-hl-comment">// parent</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(parentService.child.name)&nbsp;<span class="tb-hl-comment">// child</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;{'{'}parentService.name{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;ParentSerivce,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;ChildService</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>在上面的示例中，我们发现我们并没有实例化 ParentService 和 ChildService，但我们在 Child 组件却可以正常访问 ParentService 和 ChildService 的实例。这是 Viewfly 实现的。你无需关心这个过程是怎样发生的。只需要声明式的在构造函数中，声明依赖即可。</p>
<tb-alert data-type="warning" class="tb-alert tb-alert-warning">
  <div><strong>注意：</strong>Viewfly 不会监听 provide/inject 中的数据变化。组件的自动渲染只会根据组件在渲染时所依赖的 Signal 有关。</div>
</tb-alert>
<h2>Provider 示例</h2>
<p>在上面的示例中，我们看到了我们不但可以注入类的实例，也可以通过 useValue 的方式，直接注入一个值。使用 useValue 的这种方式，我们叫做 ValueProvider。在 Viewfly 中，我们还有更多方法来提供一个可注入的对象。</p>
<h3>useValue</h3>
<p>ValueProvider 可以让我们把任意值注入到类中，常用在一些全局配置对象，或需要注入非类实例的对象或数据的场景。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;PathInjectionToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>&lt;<span class="tb-hl-builtin">string</span>&gt;(<span class="tb-hl-string">'PathInjectionToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Inject</span>(PathInjectionToken)&nbsp;<span class="tb-hl-keyword">public</span>&nbsp;path:&nbsp;<span class="tb-hl-builtin">string</span>) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide: PathInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useValue:&nbsp;<span class="tb-hl-string">'/api'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;example =&nbsp;<span class="tb-hl-function">inject</span>(Example)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(example.path)&nbsp;<span class="tb-hl-comment">// /api</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;{'{'}example.path{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h3>classProvider</h3>
<p>classProvider 可以让我们用一个类来替换另一个类，通常是原程序的注入参数依赖于一个抽象类，再由我们提供一个实现类去实现具体的逻辑和功能。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">abstract</span>&nbsp;<span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Dialog</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">abstract</span>&nbsp;<span class="tb-hl-function">show</span>(el: Element):&nbsp;<span class="tb-hl-builtin">Promise</span>&lt;<span class="tb-hl-builtin">boolean</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">User</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(<span class="tb-hl-keyword">private</span>&nbsp;dialog: Dialog) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">login</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;dialogElement = document.<span class="tb-hl-function">createElement</span>(<span class="tb-hl-string">'div'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// dialog ui 及交互实现...</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">this</span>.dialog.<span class="tb-hl-function">show</span>(dialogElement).<span class="tb-hl-function">then</span>(isLogin =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">Tsx</span></div></pre><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// 实现 Dialog</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, provide, inject {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">MyDialog</span>&nbsp;<span class="tb-hl-keyword">implements</span>&nbsp;<span class="tb-hl-class-name">Dialog</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">show</span>(el: Element):&nbsp;<span class="tb-hl-builtin">Promise</span>&lt;<span class="tb-hl-builtin">boolean</span>&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">let</span>&nbsp;isLogin =&nbsp;<span class="tb-hl-boolean">false</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// dialog 逻辑实现...</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-builtin">Promise</span>.<span class="tb-hl-function">resolve</span>(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide: Dialog,&nbsp;<span class="tb-hl-comment">// 此处用实现类替换抽象类</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useClass: MyDialog</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;dialog =&nbsp;<span class="tb-hl-function">inject</span>(Dialog)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(dialog&nbsp;<span class="tb-hl-keyword">instanceof</span>&nbsp;<span class="tb-hl-class-name">MyDialog</span>)&nbsp;<span class="tb-hl-comment">// true</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;xxx&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h3>useFactory</h3>
<p>FactoryProvider 可以让我们使用一个函数的返回值当作注入参数，注入到类中。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Http</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(<span class="tb-hl-keyword">private</span>&nbsp;config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI:&nbsp;<span class="tb-hl-string">'/api'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout:&nbsp;<span class="tb-hl-number">5000</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>如果 useFactory 参数的内部依赖于其它类，我们还可以通过声明 deps 依赖参数数组，让注入器在调用时，自动把相关的依赖传进来。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Http</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(<span class="tb-hl-keyword">private</span>&nbsp;config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;Api,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(api: Api) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: api.isTest ?&nbsp;<span class="tb-hl-string">'/test/api'</span>&nbsp;:&nbsp;<span class="tb-hl-string">'/api'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout:&nbsp;<span class="tb-hl-number">5000</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps: [Api]</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h2>如何注入其它数据</h2>
<p>在实际应用中，很多时候不仅仅只需要注入类的实例，可能还需要注入其它数据，但通过 Typescript 自动解析元数据，是无法获取到相关依赖信息的。这时，就需要通过指定 token 的方式实现。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, InjectionToken, Inject, provide {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">interface</span>&nbsp;<span class="tb-hl-class-name">UserInfo</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-builtin">string</span>;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;UserInfoInjectionToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>&lt;<span class="tb-hl-class-name">UserInfo</span>&gt;(<span class="tb-hl-string">'UserInfoInjectionToken'</span>);</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">User</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Inject</span>(UserInfoInjectionToken)&nbsp;<span class="tb-hl-keyword">public</span>&nbsp;userInfo: UserInfo) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide: UserInfoInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'张三'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h2>多级注入器</h2>
<p>在简单的场景中，一个容器就可以满足我们的需求，但当应用越来越复杂时，我们就需要根据不同的作用域，来实现访问控制了。</p>
<p>比如，我们希望全局有一些基础的类，在任意类都能注入，还有另外一些类，会根据用户角色的不同，只能访问特定的类。如下图，我们把图中所有的小方块当作类，它们的访问关系是这样的。</p>
<p><img src="http://localhost:63342/markdownPreview/1008504219/fileSchemeResource/377f125518ff877d8dd6ea58c49f142b-tree.png?_ijt=q62gu90lq83a23bllkmabm8ocf" style="max-width:100%" class="tb-img" alt=""/></p>
<p>如图所示，每个类都可以访问当前容器的兄弟类或上层容器的类。在实际的代码组织中，我们只需要给一个容器指定一个父容器，就可以了。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} provide {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([网格, 用户])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Middle1</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Middle2</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Leaf1</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Leaf2</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-class-name">Middle2</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Middle1</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([员工列表, 薪资明细])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Middle2</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([开发规则, 服务器])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Leaf1</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([前端开发, js仓库代码])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}...{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Leaf2</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([后台开发, go仓库代码])</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}...{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>通过如上的代码组织，我们实现了示例图中的注入树结构。那么 前端开发 这个类，可以注入哪些类呢？如前面文档所述，可以注入以下类：</p>
<p><img src="http://localhost:63342/markdownPreview/1008504219/fileSchemeResource/75dbb89665e4410c4bd7db48df6a3ba5-tree1.png?_ijt=q62gu90lq83a23bllkmabm8ocf" style="max-width:100%" class="tb-img" alt=""/></p>
<h2>依赖注入规则声明</h2>
<p>我们除了可以在类的构造函数中，注入一个另一个类，我们还可以同时声明，让注入器按照一定的规则来注入，以适应更多的场景。</p>
<h3>Optional</h3>
<p>如果我们的注入参数是可选的，我们可以声明 Optional 来让注入器在注入器树上找不到相关依赖时，并不抛出异常，而是注入一个 null。</p>
<p>这种场景特别适合那种我们提供一个最基础的能力，如果用户有更好的，我们就用更好的。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Optional</span>()&nbsp;<span class="tb-hl-keyword">private</span>&nbsp;http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">if</span>&nbsp;(!<span class="tb-hl-keyword">this</span>.http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">this</span>.http =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">XMLHttpRequest</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h3>Self</h3>
<p>由于注入器是根据就近原则，依次在注入器树上查找相关类实例的，如果我们想要注入器在查找时，锁定在当前容器内查找，则可以通过 Self 装饰器来声明：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Self</span>()&nbsp;<span class="tb-hl-keyword">private</span>&nbsp;http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h3>SkipSelf</h3>
<p>当然，如果查找时，你不想从当前容器内查找，而是想要从上一层容器开始查找，则可以通过 SkipSelf 装饰器来声明：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">SkipSelf</span>()&nbsp;<span class="tb-hl-keyword">private</span>&nbsp;http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h3>Inject</h3>
<p>你还可以通过 Inject 装饰器指定注入 token，而不是通过参数类型。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Inject</span>(MyHttp)&nbsp;<span class="tb-hl-keyword">private</span>&nbsp;http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>当模块引用关系复杂时，我们需要注入的类，会在我们当前类后面才声明，这时会导致当前类在获取元数据时，拿不到类型，这时，我们也可以通过如下方式解决：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Inject</span>(<span class="tb-hl-function">forwardRef</span>(() =&gt; Http))&nbsp;<span class="tb-hl-keyword">private</span>&nbsp;http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>需要说明的是，你可以自由组合上面的装饰器。而不仅限于一个。</p>
<h2>deps 参数详解</h2>
<p>在上面的示例中，我们看到了在使用 FactoryProvider 时，可以用 deps 声明依赖参数。实际上，在 ClassProvder、ConstructorProvider 中，一样可以使用 deps 声明依赖参数，只不过，当你不声明时，注入器会根据 ClassProvder 和 ConstructorProvider 的元数据，自动帮我们做了。</p>
<p>由于 useFactory 是一个工厂函数，注入器并不能获取到其参数的依赖元数据，所以，当使用 useFactory 时，如果我们想有参数，我们是一定要声明依赖参数的。</p>
<h3>一般场景下的依赖声明</h3>
<p>普通类声明</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">MyExample</span>(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [Http, User]&nbsp;<span class="tb-hl-comment">// 按参数顺序声明依赖</span></div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>通过 InjectionToken 查找</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// const ConfigInjectionToken = new InjectionToken&lt;Config&gt;('ConfigInjectionToken')</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: ConfigInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI:&nbsp;<span class="tb-hl-string">'/api'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(config: Config) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">MyExample</span>(config)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [HttpInjectionToken]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h3>定制参数的查询规则</h3>
<p>当参数可选时</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 这里 http 可能为 null</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">MyExample</span>(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http,&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Optional</span>()], 声明 Http 可以是可选的</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>跳过当前容器，向上查找</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 这里 http 实例为 parentInjector 查找出来的，而不是当前的 injector 容器</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">MyExample</span>(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http,&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">SkipSelf</span>()],&nbsp;<span class="tb-hl-comment">// 声明 Http 可以是可选的</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>锁定当前容器</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 这里 http 实例只在当前容器内查找</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">MyExample</span>(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http,&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Self</span>()],&nbsp;<span class="tb-hl-comment">// 声明 Http 只能在当前容器查找</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>在上面的参数声明中，如果有查询规则定制，我们会把单个参数的依赖和规则放在一个数组里，如这样：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http) {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http,&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Optional</span>()]&nbsp;<span class="tb-hl-comment">// 单个参数查询规则定制</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>需要说明的是，数组内的顺序是无关紧要的，同时还可以添加多个规则，如这样：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">useFactory</span>(http: Http) {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Optional</span>(), Http,&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">SkipSelf</span>(), ]&nbsp;<span class="tb-hl-comment">// 多个规则，且顺序无关</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h2>Injector.get</h2>
<p>在获取实例时，我们会通过 injector.get 方法获取，如下：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;http = injector.<span class="tb-hl-function">get</span>(Http)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>其实，我们在前面的文档中，声明的各种查询规则，最终都是调用 injector.get 方法来实现的。这就需要我们组合传入后面的两个参数。</p>
<p>当我们要获取的依赖是可选择时：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// 如果当前容器没有 Http，在获取实例时，会抛出异常，但如果我们给了第二个参数，则会把第二个参数当作没有查找到结果时的返回值，且不会抛出异常</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;http = injector.<span class="tb-hl-function">get</span>(Http,&nbsp;<span class="tb-hl-keyword">null</span>)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>我们还可以通过 injector.get 方法的第三个参数，设置查询规则。</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} InjectFlags {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@tanbo/di'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// 设置跳过当前的容器查询</span></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;http = injector.<span class="tb-hl-function">get</span>(Http,&nbsp;<span class="tb-hl-keyword">null</span>, InjectFlags.SkipSelf)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>InjectFlags 的查询规则如下：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">enum</span>&nbsp;InjectFlags {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">/** 默认查找规则 */</span></div><div class="tb-code-line">&nbsp;&nbsp;Default =&nbsp;<span class="tb-hl-string">'Default'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">/** 锁定当前容器 */</span></div><div class="tb-code-line">&nbsp;&nbsp;Self =&nbsp;<span class="tb-hl-string">'Self'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">/** 跳过当前容器 */</span></div><div class="tb-code-line">&nbsp;&nbsp;SkipSelf =&nbsp;<span class="tb-hl-string">'SkipSelf'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">/** 可选查找 */</span></div><div class="tb-code-line">&nbsp;&nbsp;Optional =&nbsp;<span class="tb-hl-string">'Optional'</span></div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<h2>容器作用域</h2>
<p>在异步场景中，如果我们不想异步的类提前在容器内声明，可以通过 scope 的方式异步提供到指定容器。</p>
<p>创建 scope</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Scope {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@tanbo/di'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;scope =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">Scope</span>(<span class="tb-hl-string">'myScope'</span>)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// # parent-injector.ts 同步加载的文件</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} scope {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./my-scope'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;parentInjector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(<span class="tb-hl-keyword">null</span>, [<span class="tb-hl-comment">/* 你的同步类 */</span>], scope)&nbsp;<span class="tb-hl-comment">// 声明当前容器为一个具名的的 scope</span></div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>在异步文件中，添加 scope 声明：</p><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} scope {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./my-scope'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;provideIn: scope</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><span class="tb-hl-keyword">export</span>&nbsp;<span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">Example</span>&nbsp;{'{'}{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre><pre lang="TypeScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-comment">// 异步加载的文件</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} scope {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./my-scope'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} parentInjector {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./parent-injector'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Example {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'./example'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;asyncInjector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(parentInjector, [])</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;example = asyncInjector.<span class="tb-hl-function">get</span>(Example)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>由于 Example 类的装饰器中，我们提供了 provideIn 的作用域声明。所以在异步的容器中，我们可以不在当前容器内再次声明。在调用异步容器的 get 方法时，会自动把 Example 类添加到声明了相同作用域的父容器内。 需要注意的是，查找还是按照就近原则，如果在当前容器到声明了 scope 的容器的注入器树之间提供了声明了相同的 provide，那么，你得到实例的将不是 scope 容器内的实例，而是最近的那一个。</p></div>
    )
  }
}