import { inject, useRef } from '@viewfly/core'
import { ViewUpdateInjectionToken } from '../injection-tokens'
export default function() {
  const subject = inject(ViewUpdateInjectionToken)
  const ref = useRef(node => {
    subject.next(node as HTMLElement)
  })
  return function() {
    return (
      <div ref={ref}><h1>组件</h1>
<p>什么是 Viewfly 的组件？组件是由组件主体和一个渲染函数组成。其结构如下：</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// 组件主体</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// 渲染函数</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;content&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>组件的本质就是一个函数，并且我们约定组件总是以大写字母开头。其中，组件主体只会执行一次，直至销毁，而渲染函数则会随着数据的更改，执行多次。我们应当把组件主要的逻辑都编辑在组件主体内，让渲染函数只负责视图的生成。</p>
<blockquote class="tb-blockquote">渲染函数可以返回一个虚拟 DOM 节点，也可以返回一个组件（&lt;Component/&gt;）或文档片段（&lt;&gt;&lt;/&gt;），在有的情况下，我们可能不需要生成视图，这时，也可以不返回，或返回 null。</blockquote>
<h2>响应式基础</h2>
<p>如果一个组件的渲染内容永远不发生改变，我们可以把它叫做静态组件。相反，如果组件的内容会随着时间或用户的交互发生改变，我们则可叫它为动态组件。</p>
<p>我们可以使用 Signal 来管理我们需要动态变更的数据。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useSignal {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} createApp {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/platform-browser'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">0</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">div</span>&gt;{'{'}<span class="tb-hl-function">count</span>(){'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">setInterval</span>(() =&gt; count.<span class="tb-hl-function">set</span>(<span class="tb-hl-function">count</span>() +&nbsp;<span class="tb-hl-number">1</span>),&nbsp;<span class="tb-hl-number">1000</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">createApp</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'app'</span>), &lt;<span class="tb-hl-class-name">App</span>/&gt;)</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>在上面的示例中，我们在渲染模板内调用了 count()，它会返回我们存储的值，并渲染在视图中。随着时间的更改，视图也会相应发生变化。这一切都是 Viewfly 帮我们自动完成的。</p>
<p>我们要做的事情就是用 Signal 把要变化的数据存起来，并且，在任意需要的地方更改数据，视图将会随着我们的更改，自动更新。</p>
<h3>对象更新</h3>
<p>Signal 不仅可以管理简单数据，也可以管理复杂数据。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;user =&nbsp;<span class="tb-hl-function">useSignal</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'Jack'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;age:&nbsp;<span class="tb-hl-number">23</span></div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">update</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;data =&nbsp;<span class="tb-hl-function">user</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;user.<span class="tb-hl-function">set</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'Bob'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age:&nbsp;<span class="tb-hl-number">35</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;data =&nbsp;<span class="tb-hl-function">user</span>()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;username: {'{'}data.name{'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;age: {'{'}data.age{'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">button&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}update{'}'}&gt;click me&lt;/<span class="tb-hl-tag">button</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">createApp</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'app'</span>), &lt;<span class="tb-hl-class-name">App</span>/&gt;)</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>Viewfly 的更新本质是采用 === 运算符判断 signal.set() 传入的值和原来的值是否相等，如果不相等则触发更新，所以，当我们使用 Signal 管理复杂对象时，每一次 set 都应当保证传入的是一个全新的对象。</p>
<tb-alert data-type="primary" class="tb-alert tb-alert-primary">
  <div><strong>提示</strong>：管理复杂对象，直接使用 Signal 在更新值时，可能需要每一次都解构赋值，这在实际开发中是比较麻烦的，Viewfly 还提供了一个扩展库，即：@viewfly/hooks，hooks 库内有传为管理复杂对象而封装的&nbsp;<a target="_blank" href="https://viewfly.org/guide/hooks">useProduce</a>&nbsp;函数，可以更方便的管理复杂对象。</div>
</tb-alert>
<blockquote class="tb-blockquote">
  <h3><span style="color:rgb(121, 179, 15)">Viewfly 的组件是如何实现更新的？</span></h3>
  <p>Viewfly 采用依赖收集的方式实现组件更新，当 Viewfly 调用渲染函数时，会记录渲染过程中使用到的 Siganl 并记录下来，当这些记录下来的一个或多个 Signal 数据产生变化时，则会触发组件重新渲染。需要注意的是，组件的渲染是异步的，所以当你改变了某一个 Signal 的值时，并不能立即获取到最新的渲染结果。</p>
  <p>下面的组件会间隔一秒更新一次，并在控制台打印日志。</p><pre lang="Jsx" theme="vitality" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;count =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">0</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setInterval</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;count.<span class="tb-hl-function">set</span>(<span class="tb-hl-function">count</span>() +&nbsp;<span class="tb-hl-number">1</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'},&nbsp;<span class="tb-hl-number">1000</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">`count is&nbsp;</span>${'{'}<span class="tb-hl-function">count</span>(){'}'}<span class="tb-hl-string">`</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;{'{'}<span class="tb-hl-function">count</span>(){'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
  <p>下面的组件只会渲染一次，因为渲染函数并没有对变化的 Signal 产生依赖。</p><pre lang="Jsx" theme="vitality" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;count =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">0</span>)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;name =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-string">'jack'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">setInterval</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;count.<span class="tb-hl-function">set</span>(<span class="tb-hl-function">count</span>() +&nbsp;<span class="tb-hl-number">1</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'},&nbsp;<span class="tb-hl-number">1000</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">`name is&nbsp;</span>${'{'}<span class="tb-hl-function">name</span>(){'}'}<span class="tb-hl-string">`</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;{'{'}<span class="tb-hl-function">name</span>(){'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
</blockquote>
<h2>JSX 基础</h2>
<p>jsx 是 Facebook 发明的一种语言，最初在 React 中使用，由于其使用简单、灵活性高等优点，现已被众多前端类库所使用，Viewfly 也不例外。如果你已有 jsx 的使用经验，那么大多数情况下，你都可以按照原来的经验继续使用即可。</p>
<p>使用 jsx，你可以像平时在 HTML 一样，在 JavaScript 代码，直接嵌入 HTML 代码，在需要插入 js 代码的地方，只需要一对&nbsp;<code>{'{'}{'}'}</code>&nbsp;把 js 代码包裹起来即可。同时，我们约定以小写字母开头为普通 HTML 标签，以大写字母开头为组件。Viewfly 会按照你编写的代码，准确的渲染出结果。</p>
<h3>事件绑定</h3>
<p>在 jsx 中，我们可以使用&nbsp;<code>on + 事件名={'{'}callback{'}'}</code>&nbsp;的形式为标签绑定事件，如 onClick、onInput、onMousedown 等，需要注意的是，事件名第一个字母必须为大写，如果你不小心写成了小写，Viewfly 将会忽略你的绑定。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">click</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'clicked'</span>)</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line">&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}click{'}'}&gt;&lt;/<span class="tb-hl-tag">div</span>&gt;</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<tb-alert data-type="warning" class="tb-alert tb-alert-warning">
  <div><strong>提示</strong>：不要在事件绑定的回调函数上加括号&nbsp;<code>()</code>&nbsp;,否则 Viewfly 接收到的将是回调函数的返回值，除非你明确的知道，就是要这么做。</div>
</tb-alert>
<h3>条件渲染</h3>
<p>当我们根据特定的条件渲染视图时，我们可以在 jsx 中嵌入条件语句来实现。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;count =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">0</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">increment</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;count.<span class="tb-hl-function">set</span>(<span class="tb-hl-function">count</span>() +&nbsp;<span class="tb-hl-number">1</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">count</span>() %&nbsp;<span class="tb-hl-number">2</span>&nbsp;? &lt;<span class="tb-hl-tag">div</span>&gt;count is even&lt;/<span class="tb-hl-tag">div</span>&gt; : &lt;<span class="tb-hl-tag">p</span>&gt;count is odd&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">button&nbsp;</span><span class="tb-hl-attr-name">type</span>="<span class="tb-hl-attr-value">button</span>"<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}increment{'}'}&gt;点我加&nbsp;<span class="tb-hl-number">1</span>&lt;/<span class="tb-hl-tag">button</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>条件判断除了可以返回虚拟 DOM 节点外，也可以返回字符串或 null，返回 null，<strong style="color:#79b30f">Viewfly 会忽略 null 和 undefiend 的渲染。</strong></p>
<h3>循环渲染</h3>
<p>当我们需要渲染一组数据时，这里全靠手写就会变得不现实，且数据个数可能是不固定的，这时，采用循环就很有必要了。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;colors = [<span class="tb-hl-string">'blue'</span>,&nbsp;<span class="tb-hl-string">'yellow'</span>,&nbsp;<span class="tb-hl-string">'red'</span>,&nbsp;<span class="tb-hl-string">'pink'</span>]</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colors.<span class="tb-hl-function">map</span>((color, index) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">p</span>&gt;第 {'{'}index +&nbsp;<span class="tb-hl-number">1</span>{'}'} 个颜色为：{'{'}color{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h3>style 渲染</h3>
<p>style 支持一个字符串或一个简单对象，当值要根据数据动态取值是，对象是一个好选择。需要注意的是，Viewfly 默认不会添加单位，如像素值只能写成字符串 50px 而不是数字 50。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;height =&nbsp;<span class="tb-hl-function">useSignal</span>()</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">increaseHeight</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;height.<span class="tb-hl-function">set</span>(<span class="tb-hl-function">height</span>() +&nbsp;<span class="tb-hl-number">10</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}increaseHeight{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div style={'{'}{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;<span class="tb-hl-function">height</span>() +&nbsp;<span class="tb-hl-string">'px'</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;<span class="tb-hl-string">'green'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}{'}'}&gt;text&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">style</span>="<span class="tb-hl-attr-name">border</span>: 1px solid #ccc"&gt;text&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h3>class 渲染</h3>
<p>Viewfly 中，class 可以支持普通字符串、对象或包含字符串或对象的数组。当为对象时，Viewfly 会遍历传入的对象，当 key 对应的值为判定为 true 时，Viewfly 将把 key 作为 class 名字渲染进最终结果中。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;isShow =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-boolean">false</span>)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>="<span class="tb-hl-attr-value">container box</span>"&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>={'{'}[<span class="tb-hl-string">'nav'</span>,&nbsp;<span class="tb-hl-string">'bg-gray'</span>]{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>={'{'}{'{'}'content':&nbsp;<span class="tb-hl-boolean">true</span>, 'is-show':&nbsp;<span class="tb-hl-function">isShow</span>(){'}'}{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>={'{'}[<span class="tb-hl-string">'footer'</span>, {'{'}'active':&nbsp;<span class="tb-hl-function">isShow</span>(){'}'}]{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组和对象组合</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h2>子组件</h2>
<p>在实际应用中，一个组件肯定无法满足复杂的业务需求，我们可以拆分不同的部分，并以子组件的形式组装起来，就像搭积木一样。这有利于降低单个组件的复杂度，也可以在不同的地方复用已有的组件。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Header</span>() {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Main</span>() {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Footer</span>() {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Header</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Main</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Footer</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h3>组件属性</h3>
<p>当子组件一部分数据需要由使用它的地方确定时，我们可以通过组件属性（Props）传递给子组件。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Button</span>(props) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">button&nbsp;</span><span class="tb-hl-attr-name">type</span>={'{'}props.type{'}'}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}props.onClick{'}'}&gt;Button&lt;/<span class="tb-hl-tag">button</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">childClick</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'子组件被点击了'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Button</span><span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">type</span>="<span class="tb-hl-attr-value">button</span>"<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}childClick{'}'}/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>当父组件传给子组件的属性产生变化时，子组件总是可以通过 props 获取最父组件传入的数据。</p>
<p><strong>需要注意的是，当我们把 props &nbsp;解构后，将只能拿到初始的值</strong>。这是因为，解构后，props 的属性就变成了一个本地变量，而不是一个响应式的对象了。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Button</span>({'{'}type, onClick{'}'}) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// type 和 onClick 不会再更新</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">button&nbsp;</span><span class="tb-hl-attr-name">type</span>={'{'}props.type{'}'}<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}props.onClick{'}'}&gt;Button&lt;/<span class="tb-hl-tag">button</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">childClick</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'子组件被点击了'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Button</span><span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">type</span>="<span class="tb-hl-attr-value">button</span>"<span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}childClick{'}'}/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h3>组件子节点</h3>
<p>在我们写 HTML 时，大多数标签都可以在标签内再嵌入子元素，这在组件中，也是可以实现的。我们在任意组件内嵌套的元素，总是会在 props 的 children 字段中。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>(props) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-tag">p</span>&gt;{'{'}props.children{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>&gt;Text from Parent Component.&lt;/<span class="tb-hl-class-name">Child</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>有时我们可能需要给子组件传递更多的文档片段，只靠 children 就满足不了我们的需求，这时，子组件可以对外提供更多的选项，供父组件传入。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>(props) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>="<span class="tb-hl-attr-value">heading</span>"&gt;{'{'}props.heading{'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">class</span>="<span class="tb-hl-attr-value">content</span>"&gt;{'{'}props.children{'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span><span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">heading</span>={'{'}&lt;<span class="tb-hl-tag">h1</span>&gt;heading&lt;/<span class="tb-hl-tag">h1</span>&gt;{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Text from Parent Component.</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-class-name">Child</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<h2>渲染文档片段</h2>
<p>有时我们需要重复一段结构，却不想为这一段结构添加额外的父节点，但循环渲染却不能返回两个节点，这时，Fragment 将会是一个好选择。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;colors = [<span class="tb-hl-string">'blue'</span>,&nbsp;<span class="tb-hl-string">'yellow'</span>,&nbsp;<span class="tb-hl-string">'red'</span>,&nbsp;<span class="tb-hl-string">'pink'</span>]</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colors.<span class="tb-hl-function">map</span>((color, index) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">p</span>&gt;这是第 {'{'}index +&nbsp;<span class="tb-hl-number">1</span>{'}'} 个颜色&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">p</span>&gt;它的值为：{'{'}color{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>Fragment 不仅可以在循环中使用，也可在以其它地方使用，甚至组件的根节点，也可以是一个 Fragment。</p>
<tb-alert data-type="info" class="tb-alert tb-alert-info">
  <div><strong>小提示：</strong>Fragment 本质是一个组件，它由 Viewfly 内核实现，Fragment 不生成任何 DOM 节点，也没有任何功能。仅仅是作为一个组装一组子节点的语法糖。</div>
</tb-alert>
<h1>数据共享</h1>
<p>在前面的示例中，我们的 Signal 都是声明在组件内的。实际上，我们完全可以把 Signal 声明在组件外，这样，多个组件都可以访问到同一个 Signal，而不需要以 Props 的形式传递了。</p>
<p>多个组件共享 Signal 给数据通信提供了非常大的方便。并且，如果任意一个组件在渲染时，依赖了这个 Signal，那么，当被依赖的 Signal 数据更新时，这些组件都将会得到更新。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;commonState =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-string">'old state!'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">updateState</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;commonState.<span class="tb-hl-function">set</span>(<span class="tb-hl-string">'new state!'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">p</span>&gt;child:{'{'}<span class="tb-hl-function">commonState</span>(){'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">button&nbsp;</span><span class="tb-hl-attr-name">onClick</span>={'{'}updateState{'}'}&gt;update state&lt;/<span class="tb-hl-tag">button</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;state: {'{'}<span class="tb-hl-function">commonState</span>(){'}'}&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">createApp</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'app'</span>), &lt;<span class="tb-hl-class-name">App</span>/&gt;)</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p><br/></p>
<h1>数据监听</h1>
<p>在一些情况下，我们需要在数据产生变化时执行一些副作用。如，发起新的请求、更改一些 DOM 等。在 Viewfly 中，你可以使用 useEffect 实现对数据变化的监听。</p>
<h2>useEffect()&nbsp;</h2>
<p>useEffect 可以监听一个或一组 Signal 的变化，并在其中任意一个 Signal 的值产生变化时，调用传入的回调函数。</p>
<p>监听一个 Signal 的变化。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useSignal, useEffect {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count1 =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">10</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">useEffect</span>(count1, (newValue, oldValue) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">`count1 changed, newVlaue is&nbsp;</span>${'{'}newVlaue{'}'}<span class="tb-hl-string">, oldValue is&nbsp;</span>${'{'}oldValue{'}'}<span class="tb-hl-string">`</span>)</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">count1.<span class="tb-hl-function">set</span>(<span class="tb-hl-number">11</span>)</div><div class="tb-code-line"><span class="tb-hl-comment">// count1 changed, newVlaue is 10, oldValue is 11</span></div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p>监听一组 &nbsp;Signal 的变化，Viewfly 会把最新的值以数据方式传入回调函数参数。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useSignal, useEffect {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count1 =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">10</span>)</div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count2 =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">20</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">useEffect</span>([count1, count2], (newValues, oldValues) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">`data changed, newVlaues is&nbsp;</span>${'{'}newVlaues{'}'}<span class="tb-hl-string">, oldValues is&nbsp;</span>${'{'}oldValues{'}'}<span class="tb-hl-string">`</span>)</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">count1.<span class="tb-hl-function">set</span>(<span class="tb-hl-number">11</span>)</div><div class="tb-code-line"><span class="tb-hl-comment">// count1 changed, newVlaues is 11,20, oldValues is 10,20</span></div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p>useEffect 也可以在第一个参数传入一个函数，函数内包含对 Signal 运算后产生的值，Viewfly 会收集函数内依赖的 Signal，并在这些 Signal 中任意一个发生变化时，重新调用该函数。如果两次计算产生了不一样的返回值，则 Viewfly 会调用第二个回调函数，并传入新值和旧值。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useSignal, useEffect {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count1 =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">10</span>)</div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;count2 =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">20</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">useEffect</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">count1</span>() +&nbsp;<span class="tb-hl-function">count2</span>()</div><div class="tb-code-line">{'}'}, (newValue, oldValue) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">`data changed, newVlaues is&nbsp;</span>${'{'}newVlaue{'}'}<span class="tb-hl-string">, oldValues is&nbsp;</span>${'{'}oldValue{'}'}<span class="tb-hl-string">`</span>)</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">count1.<span class="tb-hl-function">set</span>(<span class="tb-hl-number">11</span>)</div><div class="tb-code-line"><span class="tb-hl-comment">// data changed, newVlaues is 31, oldValues is 30</span></div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<h3>清理副作用</h3>
<p>当数据变更时，可能会产生一些副作用，但这些副作用不应该一起存在，你可以在回调函数中返回一个函数，用于清理上一次回调的副作用。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-function">useEffect</span>(signal, () =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;timer =&nbsp;<span class="tb-hl-function">setTimeout</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// do something...</span></div><div class="tb-code-line">&nbsp;&nbsp;{'}'},&nbsp;<span class="tb-hl-number">1000</span>)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">clearTimeout</span>(timer)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'})</div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p>useEffect 还会返回一个函数，可以让你在任何时机取消监听。并且，如果已产生了数据变化，同时你也返回了清理副作用的回调函数，这个回调函数也会一并调用。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;unListen =&nbsp;<span class="tb-hl-function">useEffect</span>(signal, () =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;timer =&nbsp;<span class="tb-hl-function">setTimeout</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-comment">// do something...</span></div><div class="tb-code-line">&nbsp;&nbsp;{'}'},&nbsp;<span class="tb-hl-number">1000</span>)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">clearTimeout</span>(timer)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// do something</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">unListen</span>()</div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<tb-alert data-type="primary" class="tb-alert tb-alert-primary">
  <div><strong>提示</strong>：如果 useEffect 声明在组件内，组件会在销毁时，自动清理 useEffect 的监听。等同于 Viewfly 自动调用了 useEffect 返回的函数。</div>
</tb-alert>
<h2>useDerived() 派生值</h2>
<p>useDerived 用于执行一个回调函数，并根据函数的返回值派生一个新的 Signal，useDerived 还会自动监听函数内依赖的 Signal，当这个 Siganl 数据产生变化时，会重新执行回调函数，并把返回的值作为派生 Signal 的新值。</p>
<p>useDerived 还可以传入第 2 个回调函数，当派生 Signal 值更新时，会调用这个回调函数，当函数返回为 false 时，useDerived 将不再继续监听依赖 Signal 的变化。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;sA =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">1</span>)</div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;sB =&nbsp;<span class="tb-hl-function">useSignal</span>(<span class="tb-hl-number">2</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;sC =&nbsp;<span class="tb-hl-function">useDerived</span>(() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">sA</span>() +&nbsp;<span class="tb-hl-function">sB</span>()</div><div class="tb-code-line">{'}'}, (v) =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-comment">// 可选的回调函数，当计算值大于等于 5 时，将不再监听 sA 和 sB 的变化</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;v &lt;&nbsp;<span class="tb-hl-number">5</span></div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">console.<span class="tb-hl-function">log</span>(<span class="tb-hl-function">sC</span>())&nbsp;<span class="tb-hl-comment">// 3</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">sA.<span class="tb-hl-function">set</span>(<span class="tb-hl-number">3</span>)</div><div class="tb-code-line">console.<span class="tb-hl-function">log</span>(<span class="tb-hl-function">sC</span>())&nbsp;<span class="tb-hl-comment">// 5</span></div><div class="tb-code-line"><span class="tb-hl-comment">// 当前值已等于 5，已取消监听，后续更改将不会再更新 sC 的值</span></div><div class="tb-code-line">sA.<span class="tb-hl-function">set</span>(<span class="tb-hl-number">4</span>)</div><div class="tb-code-line">console.<span class="tb-hl-function">log</span>(<span class="tb-hl-function">sC</span>())&nbsp;<span class="tb-hl-comment">// 5</span></div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p>大多数情况下，你不需要使用 useDerived 来派生一个新值，推荐直接使用函数即可。直接使用函数更容易理解，且性能更优。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">sC</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;<span class="tb-hl-function">sA</span>() +&nbsp;<span class="tb-hl-function">sB</span>()</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">console.<span class="tb-hl-function">log</span>(<span class="tb-hl-function">sC</span>())</div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p><br/></p>
<h1>获取节点实例</h1>
<h2>useRef()</h2>
<p>useRef 函数会返回一个 Ref 对象。将返回的 Ref 对象添加到虚拟 DOM 节点的 ref 属性上，Viewfly 将会在真实 DOM 渲染完成时，调用 useRef 函数调用时传入的回调函数，并把真实的 DOM 节点通过参数传入第一个参数。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useRef {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;nodeRef =&nbsp;<span class="tb-hl-function">useRef</span>(nativeNode =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(nativeNode)</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={'{'}nodeRef{'}'}&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">p&nbsp;</span><span class="tb-hl-attr-name">ref</span>={'{'}nodeRef{'}'}/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>和其它前端框架不同的是，Viewfly 中同一个 Ref 对象，可以绑定到多个 DOM 节点上，并且，每个节点都会生效。你甚至可以把 Ref 当成指令来使用。</p>
<p>虚拟 DOM 节点的 ref 属性还可以绑定一组 Ref 对象。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} useRef {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;nodeRef =&nbsp;<span class="tb-hl-function">useRef</span>(nativeNode =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(nativeNode)</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;nodeRef2 =&nbsp;<span class="tb-hl-function">useRef</span>(node =&gt; {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div&nbsp;</span><span class="tb-hl-attr-name">ref</span>={'{'}[nodeRef, nodeRef2]{'}'}&gt;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>在 useRef 传入的回调函数中，你还可以返回一个函数，用于在 DOM 节点销毁后，清理副作用。</p><pre lang="JavaScript" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;ref =&nbsp;<span class="tb-hl-function">useRef</span>(node =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;fn = () =&gt; {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;node.<span class="tb-hl-function">addEventListener</span>(<span class="tb-hl-string">'click'</span>, fn)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;node.<span class="tb-hl-function">removeEventListener</span>(<span class="tb-hl-string">'click'</span>, fn)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'})</div></div><span class="tb-pre-lang">JavaScript</span></div></pre>
<p><br/></p>
<h1>组件方法</h1>
<p>一般情况下，我们在组件内只需要返回一个渲染函数即可，但当组件需要对外提供一些方法时，仅返回一个函数是不够的，这时，我们可以返回一个对象。父组件则可获取到子组件返回的对象，并可访问对象上的属性和方法。</p><pre lang="Jsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">show</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'method show called!'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">$render</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;xxx&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;childRef =&nbsp;<span class="tb-hl-function">useRef</span>(childInstance =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;childInstance.<span class="tb-hl-function">show</span>()</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-class-name">Child</span><span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">ref</span>={'{'}childRef{'}'}/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>从上面的示例中，我们从对象中返回了 show 方法，并在父组件中，使用 ref 获取了子组件返回的对象。</p>
<p>需要注意的是，在返回对象中，我们的 render 函数，必须叫作 $render，这是为了区分 Viewfly 内部依赖方法和用户自定义方法的约定。在我们的使用中，不应用返回以 $ 开头的属性和方法。</p>
<p>如果你使用 TypeScript，在使用 useRef 时，你可以通过如下方法获取子组件返回对象的类型。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">show</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'method show called!'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">$render</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;xxx&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;childRef =&nbsp;<span class="tb-hl-function">useRef</span>&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;Child&gt;(childInstance =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;childInstance.<span class="tb-hl-function">show</span>()</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;&lt;<span class="tb-hl-class-name">Child</span><span class="tb-hl-tag">&nbsp;</span><span class="tb-hl-attr-name">ref</span>={'{'}childRef{'}'}/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>或者可以通过 Viewfly 提供的工具类型，直接获取子组件返回的类型。</p><pre lang="Tsx" theme="starry" line-number class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">show</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(<span class="tb-hl-string">'method show called!'</span>)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-function">$render</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;xxx&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">type</span>&nbsp;<span class="tb-hl-class-name">ChildInstanceType</span>&nbsp;= ExtractInstanceType&lt;<span class="tb-hl-keyword">typeof</span>&nbsp;Child&gt;</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p><br/></p></div>
    )
  }
}