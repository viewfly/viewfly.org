import { inject, useRef } from '@viewfly/core'
import { ViewUpdateInjectionToken } from '../injection-tokens'
export default function() {
  const subject = inject(ViewUpdateInjectionToken)
  const ref = useRef(node => {
    subject.next(node as HTMLElement)
  })
  return function() {
    return (
      <div ref={ref}><h1>依赖注入</h1>
<p>依赖注入是 IoC（Inversion of Control）控制反转技术的一种实现，是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度，Viewfly 通过集成&nbsp;<a target="_blank" href="https://github.com/tbhuabi/di">@tanbo/di</a>&nbsp;实现了类似 Angular 一样的控制反转能力。</p>
<p>要完整使用 Viewfly 提供的依赖注入能力，需要 TypeScript 的支持，并且要在 tsconfig 中开启如下配置，并且确保你的编译器可以正确编辑装装饰器。</p><pre lang="JSON" theme="light" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-attr-name">"compilerOptions"</span>: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-attr-name">"emitDecoratorMetadata"</span>:&nbsp;<span class="tb-hl-boolean">true</span>,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-attr-name">"experimentalDecorators"</span>:&nbsp;<span class="tb-hl-boolean">true</span>,</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">JSON</span></div></pre>
<p>同时，你还需要安装 reflect-metadata 这个元数据兼容库，并在应用入口处导入它。</p><pre lang="" theme="Light" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">npm install reflect-metadata</div></div><span class="tb-pre-lang"></span></div></pre><pre lang="TypeScript" theme="Light" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;<span class="tb-hl-string">'reflect-metadata'</span></div><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} createApp {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/platform-browser'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}...{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-function">createApp</span>(document.<span class="tb-hl-function">getElementById</span>(<span class="tb-hl-string">'app'</span>, &lt;App/&gt;)</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>当然，如果你不想使用装饰器，我们也可以完全通过其它方式实现类似 Vue 的 provide/inject 或 React 的 Context 的效果。</p>
<h2>基本使用</h2>
<p>Viewfly 提供了 provide 和 inject 两个函数，用于在组件渲染上下文中实现跨组件通讯能力。</p><pre lang="Jsx" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} inject, provide, InjectionToken {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;UserToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>(<span class="tb-hl-string">'UserToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;user =&nbsp;<span class="tb-hl-function">inject</span>(UserToken)</div><div class="tb-code-line">&nbsp;&nbsp;console.<span class="tb-hl-function">log</span>(user.name)&nbsp;<span class="tb-hl-comment">// 张三</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;{'{'}user.name{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: UserToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'张三'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Jsx</span></div></pre>
<p>在上面的示例中，我们通过在上层组件通过 provide 函数提供了一个 UserToken，在下层组件使用 inject 函数获取 UserToken，即获取到上层组件提供的数据。</p>
<p>我们看到在调用 &nbsp;provide 函数时，我们传入了一个对象，对象有 provide 和 useValue 两个属性。我们可以简单把 provide 属性的值作为 key，把 useValue 属性的值作为 value。</p>
<p>要注意的是，provide 的值必须为一个 InjectionToken 的实例。这在 JavaScript 编写中并没有太大意义，但在 TypeScript 场景中，它将为我们提供准确的类型提示能力，我们将上面的示例改为 TypeScript。</p><pre lang="TypeScript" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content tb-color-content-highlight"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} inject, provide, InjectionToken {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">interface</span>&nbsp;<span class="tb-hl-class-name">User</span>&nbsp;{'{'}</div><div class="tb-code-line-emphasize tb-code-line">&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-builtin">string</span></div><div class="tb-code-line-emphasize tb-code-line">{'}'}</div><div class="tb-code-line-emphasize tb-code-line"><br/></div><div class="tb-code-line-emphasize tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;UserToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>&lt;<span class="tb-hl-class-name">User</span>&gt;(<span class="tb-hl-string">'UserToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;user =&nbsp;<span class="tb-hl-function">inject</span>(UserToken)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(user.name)&nbsp;<span class="tb-hl-comment">// 张三</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;p&gt;{'{'}user.name{'}'}&lt;/p&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: UserToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="tb-hl-string">'张三'</span></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'})</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">TypeScript</span></div></pre>
<p>现在，如果我们在子组件尝试访问 user.age 时，你将会发现，TypeScript 将会抛出错误信息。</p>
<div class="tb-blockquote">Viewfly 的依赖注入实现，基本和 Angular 类似，如果你有 Angular 的使用经验，你完全可以照搬原来的经验。当然，没有也没关系，Viewfly 的依赖注入 API 简单多了。</div>
<h2>Injectable()</h2>
<p>常见的依赖注入，往往是基于 Class 的，我们可以通过 Injectable 装饰器，把一个类标记为可注入的，即可使用 Viewfly 自动管理依赖和自动实例化的能力。</p><pre lang="Tsx" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, provide, inject {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// 声明类是可注入的</span></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">ChildService</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name =&nbsp;<span class="tb-hl-string">'child'</span></div><div class="tb-code-line">&nbsp;&nbsp;index:&nbsp;<span class="tb-hl-builtin">number</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>() {'{'}{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-comment">// 声明类是可注入的</span></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">ParentSerivce</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name =&nbsp;<span class="tb-hl-string">'parent'</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(<span class="tb-hl-keyword">public</span>&nbsp;child: ChildService) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">Child</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">const</span>&nbsp;parentService =&nbsp;<span class="tb-hl-function">inject</span>(ParentSerivce)</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(parentService.name)&nbsp;<span class="tb-hl-comment">// parent</span></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(parentService.child.name)&nbsp;<span class="tb-hl-comment">// child</span></div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; &lt;<span class="tb-hl-tag">p</span>&gt;{'{'}parentService.name{'}'}&lt;/<span class="tb-hl-tag">p</span>&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">function</span>&nbsp;<span class="tb-hl-function">App</span>() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">provide</span>([</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;ParentSerivce,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;ChildService</div><div class="tb-code-line">&nbsp;&nbsp;])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;() =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="tb-hl-keyword">return</span>&nbsp;(</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class="tb-hl-class-name">Child</span>/&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="tb-hl-tag">div</span>&gt;</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<p>在上面的示例中，我们发现我们并没有实例化 ParentService 和 ChildService，但我们在 Child 组件却可以正常访问 ParentService 和 ChildService 的实例。这是 Viewfly 实现的。你无需关心这个过程是怎样发生的。只需要声明式的在构造函数中，声明依赖即可。</p>
<tb-alert data-type="warning" class="tb-alert tb-alert-warning">
  <div>注意：Viewfly 不会监听 provide/inject 中的数据变化。组件的自动渲染只会根据组件在渲染时所依赖的 Signal 有关。</div>
</tb-alert>
<h2 style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">Provider 示例</span></h2>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">在上面的示例中，我们看到了我们不但可以注入类的实例，也可以通过 useValue 的方式，直接注入一个值。使用 useValue 的这种方式，我们叫做 ValueProvider。在 @tanbo/di 中，我们还有更多方法来提供一个可注入的对象。</span></p>
<h3 style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">useValue</span></h3>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">ValueProvider 可以让我们把任意值注入到类中，常用在一些全局配置对象，或需要注入非类实例的对象或数据的场景。</span></p><pre lang="Tsx" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line"><span class="tb-hl-keyword">import</span>&nbsp;{'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'}&nbsp;<span class="tb-hl-keyword">from</span>&nbsp;<span class="tb-hl-string">'@viewfly/core'</span>;</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;PathInjectionToken =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">InjectionToken</span>&lt;<span class="tb-hl-builtin">string</span>&gt;(<span class="tb-hl-string">'PathInjectionToken'</span>)</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@<span class="tb-hl-function">Injectable</span>()</div><div class="tb-code-line"><span class="tb-hl-keyword">class</span>&nbsp;<span class="tb-hl-class-name">HttpExample</span>&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;<span class="tb-hl-function">constructor</span>(@<span class="tb-hl-function">Inject</span>(PathInjectionToken)&nbsp;<span class="tb-hl-keyword">public</span>&nbsp;path:&nbsp;<span class="tb-hl-builtin">string</span>) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;injector =&nbsp;<span class="tb-hl-keyword">new</span>&nbsp;<span class="tb-hl-class-name">ReflectiveInjector</span>(<span class="tb-hl-keyword">null</span>, [</div><div class="tb-code-line">&nbsp;&nbsp;HttpExample,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: PathInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue:&nbsp;<span class="tb-hl-string">'/api'</span></div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line"><span class="tb-hl-keyword">const</span>&nbsp;http = injector.<span class="tb-hl-function">get</span>(HttpExample)</div><div class="tb-code-line"><span class="tb-hl-builtin">console</span>.<span class="tb-hl-function">log</span>(http)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang">Tsx</span></div></pre>
<h3 style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">classProvider</span></h3>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">classProvider 可以让我们用一个类来替换另一个类，通常是原程序的注入参数依赖于一个抽象类，再由我们提供一个实现类去实现具体的逻辑和功能。</span></p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 原程序</div><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">abstract class Dialog {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;abstract show(el: Element): Promise&lt;boolean&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class User {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private dialog: Dialog) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;login() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;const dialogElement = document.createElement('div')</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;// dialog ui 及交互实现...</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;this.dialog.show(dialogElement).then(isLogin =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 实现 Dialog</div><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class MyDialog implements Dialog {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;show(el: Element): Promise&lt;boolean&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;let isLogin = false</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;// dialog 逻辑实现...</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;return Promise.resolve(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Dialog,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useClass: MyDialog</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const user = injector.get(User)</div><div class="tb-code-line">user.login()</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3 style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">useFactory</span></h3>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">FactoryProvider 可以让我们使用一个函数的返回值当作注入参数，注入到类中。</span></p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Http {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: '/api',</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: 5000</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p style="background-color:rgb(255, 255, 255)"><span style="color:rgb(73, 80, 96)">如果 useFactory 参数的内部依赖于其它类，我们还可以通过声明 deps 依赖参数数组，让注入器在调用时，自动把相关的依赖传进来。</span></p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Http {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;App,</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(app: App) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: app.isTest ? '/test/api' : '/api',</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: 5000</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [App]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p><br/></p>
<p><br/></p>
<p><br/></p>
<h2>如何注入其它数据</h2>
<p>在实际应用中，很多时候不仅仅只需要注入类的实例，可能还需要注入其它数据，但通过 Typescript 自动解析元数据，是无法获取到相关依赖信息的。这时，就需要通过指定 token 的方式实现。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">interface UserInfo {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;name: string;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const UserInfoInjectionToken = new InjectionToken&lt;UserInfo&gt;('UserInfoInjectionToken');</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class User {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Inject(UserInfoInjectionToken) public userInfo: UserInfo) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;User, {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: UserInfoInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: '张三'</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">]);</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const instance = injector.get(User);</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h2>多级注入器</h2>
<p>在简单的场景中，一个容器就可以满足我们的需求，但当应用越来越复杂时，我们就需要根据不同的作用域，来实现访问控制了。</p>
<p>比如，我们希望全局有一些基础的类，在任意类都能注入，还有另外一些类，会根据用户角色的不同，只能访问特定的类。如下图，我们把图中所有的小方块当作类，它们的访问关系是这样的。</p>
<p><img src="http://localhost:63342/markdownPreview/1133343401/fileSchemeResource/377f125518ff877d8dd6ea58c49f142b-tree.png?_ijt=8junjl2l3vnmhs7smet0aln1ia" style="max-width:100%" class="tb-img" alt=""/></p>
<p>如图所示，每个类都可以访问当前容器的兄弟类或上层容器的类。在实际的代码组织中，我们只需要给一个容器指定一个父容器，就可以了。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} ReflectiveInjector {'}'} from './reflective-injector';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const rootInjector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;网络,</div><div class="tb-code-line">&nbsp;&nbsp;用户</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const middleInjector1 = new ReflectiveInjector(rootInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;员工列表,</div><div class="tb-code-line">&nbsp;&nbsp;薪资明细</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const middleInjector2 = new ReflectiveInjector(rootInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;开发规则,</div><div class="tb-code-line">&nbsp;&nbsp;服务器</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const leafInjector1 = new ReflectiveInjector(middleInjector2, [</div><div class="tb-code-line">&nbsp;&nbsp;前端开发,</div><div class="tb-code-line">&nbsp;&nbsp;JS代码仓库</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const leafInjector2 = new ReflectiveInjector(middleInjector2, [</div><div class="tb-code-line">&nbsp;&nbsp;后台开发,</div><div class="tb-code-line">&nbsp;&nbsp;GO代码仓库</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>通过如上的代码组织，我们实现了示例图中的注入树结构。那么 前端开发 这个类，可以注入哪些类呢？如前面文档所述，可以注入以下类：</p>
<p><img src="http://localhost:63342/markdownPreview/1133343401/fileSchemeResource/75dbb89665e4410c4bd7db48df6a3ba5-tree1.png?_ijt=8junjl2l3vnmhs7smet0aln1ia" style="max-width:100%" class="tb-img" alt=""/></p>
<h2>Provider 示例</h2>
<p>在上面的示例中，我们看到了我们不但可以注入类的实例，也可以通过 useValue 的方式，直接注入一个值。使用 useValue 的这种方式，我们叫做 ValueProvider。在 @tanbo/di 中，我们还有更多方法来提供一个可注入的对象。</p>
<h3>useValue</h3>
<p>ValueProvider 可以让我们把任意值注入到类中，常用在一些全局配置对象，或需要注入非类实例的对象或数据的场景。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const PathInjectionToken = new InjectionToken&lt;string&gt;('PathInjectionToken')</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class HttpExample {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Inject(PathInjectionToken) public path: string) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;HttpExample,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: PathInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: '/api'</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const http = injector.get(HttpExample)</div><div class="tb-code-line">console.log(http)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>classProvider</h3>
<p>classProvider 可以让我们用一个类来替换另一个类，通常是原程序的注入参数依赖于一个抽象类，再由我们提供一个实现类去实现具体的逻辑和功能。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 原程序</div><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">abstract class Dialog {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;abstract show(el: Element): Promise&lt;boolean&gt;</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class User {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private dialog: Dialog) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;login() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;const dialogElement = document.createElement('div')</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;// dialog ui 及交互实现...</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;this.dialog.show(dialogElement).then(isLogin =&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'})</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 实现 Dialog</div><div class="tb-code-line">import {'{'} Injectable, InjectionToken, Inject, ReflectiveInjector {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class MyDialog implements Dialog {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;show(el: Element): Promise&lt;boolean&gt; {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;let isLogin = false</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;// dialog 逻辑实现...</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;return Promise.resolve(isLogin)</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Dialog,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useClass: MyDialog</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const user = injector.get(User)</div><div class="tb-code-line">user.login()</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>useFactory</h3>
<p>FactoryProvider 可以让我们使用一个函数的返回值当作注入参数，注入到类中。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Http {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory() {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: '/api',</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: 5000</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>如果 useFactory 参数的内部依赖于其它类，我们还可以通过声明 deps 依赖参数数组，让注入器在调用时，自动把相关的依赖传进来。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Http {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(private config: HttpConfig) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const injector = new ReflectiveInjector(null, [</div><div class="tb-code-line">&nbsp;&nbsp;App,</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: HttpConfig,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(app: App) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: app.isTest ? '/test/api' : '/api',</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: 5000</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [App]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h2>依赖注入规则声明</h2>
<p>我们除了可以在类的构造函数中，注入一个另一个类，我们还可以同时声明，让注入器按照一定的规则来注入，以适应更多的场景。</p>
<h3>Optional</h3>
<p>如果我们的注入参数是可选的，我们可以声明 Optional 来让注入器在注入器树上找不到相关依赖时，并不抛出异常，而是注入一个 null。</p>
<p>这种场景特别适合那种我们提供一个最基础的能力，如果用户有更好的，我们就用更好的。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Example {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Optional() private http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;if (!this.http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.http = new XMLHttpRequest()</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>Self</h3>
<p>由于注入器是根据就近原则，依次在注入器树上查找相关类实例的，如果我们想要注入器在查找时，锁定在当前容器内查找，则可以通过 Self 装饰器来声明：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Example {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Self() private http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>SkipSelf</h3>
<p>当然，如果查找时，你不想从当前容器内查找，而是想要从上一层容器开始查找，则可以通过 SkipSelf 装饰器来声明：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Example {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@SkipSelf() private http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>Inject</h3>
<p>你还可以通过 Inject 装饰器指定注入 token，而不是通过参数类型。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Example {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Inject(MyHttp) private http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>当模块引用关系复杂时，我们需要注入的类，会在我们当前类后面才声明，这时会导致当前类在获取元数据时，拿不到类型，这时，我们也可以通过如下方式解决：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">@Injectable()</div><div class="tb-code-line">class Example {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;constructor(@Inject(forwardRef(() =&gt; Http)) private http: Http) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>需要说明的是，你可以自由组合上面的装饰器。而不仅限于一个。</p>
<h3><br/></h3>
<h2>deps 参数详解</h2>
<p>在上面的示例中，我们看到了在使用 FactoryProvider 时，可以用 deps 声明依赖参数。实际上，在 ClassProvder、ConstructorProvider 中，一样可以使用 deps 声明依赖参数，只不过，当你不声明时，注入器会根据 ClassProvder 和 ConstructorProvider 的元数据，自动帮我们做了。</p>
<p>由于 useFactory 是一个工厂函数，注入器并不能获取到其参数的依赖元数据，所以，当使用 useFactory 时，如果我们想有参数，我们是一定要声明依赖参数的。</p>
<h3>一般场景下的依赖声明</h3>
<p>普通类声明</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyExample(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [Http, User] // 按参数顺序声明依赖</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>通过 InjectionToken 查找</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// const ConfigInjectionToken = new InjectionToken&lt;Config&gt;('ConfigInjectionToken')</div><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: ConfigInjectionToken,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useValue: {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseURI: '/api'</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(config: Config) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyExample(config)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [HttpInjectionToken]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h3>定制参数的查询规则</h3>
<p>当参数可选时</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 这里 http 可能为 null</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyExample(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http, new Optional()], 声明 Http 可以是可选的</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>跳过当前容器，向上查找</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 这里 http 实例为 parentInjector 查找出来的，而不是当前的 injector 容器</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyExample(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http, new SkipSelf()], // 声明 Http 可以是可选的</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>锁定当前容器</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User,</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http, user: User) {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 这里 http 实例只在当前容器内查找</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyExample(http, user)</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http, new Self()], // 声明 Http 只能在当前容器查找</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>在上面的参数声明中，如果有查询规则定制，我们会把单个参数的依赖和规则放在一个数组里，如这样：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http) {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Http, new Optional()] // 单个参数查询规则定制</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>需要说明的是，数组内的顺序是无关紧要的，同时还可以添加多个规则，如这样：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;{'{'}</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;provide: Example,</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;useFactory(http: Http) {'{'}</div><div class="tb-code-line"><br/></div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;{'}'},</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;deps: [</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[new Optional(), Http, new SkipSelf(), ] // 多个规则，且顺序无关</div><div class="tb-code-line">&nbsp;&nbsp;&nbsp;&nbsp;]</div><div class="tb-code-line">&nbsp;&nbsp;{'}'}</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h2>Injector.get</h2>
<p>在获取实例时，我们会通过 injector.get 方法获取，如下：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">const injector = new ReflectiveInjector(parentInjector, [</div><div class="tb-code-line">&nbsp;&nbsp;Http,</div><div class="tb-code-line">&nbsp;&nbsp;User</div><div class="tb-code-line">])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const http = injector.get(Http)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>其实，我们在前面的文档中，声明的各种查询规则，最终都是调用 injector.get 方法来实现的。这就需要我们组合传入后面的两个参数。</p>
<p>当我们要获取的依赖是可选择时：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 如果当前容器没有 Http，在获取实例时，会抛出异常，但如果我们给了第二个参数，则会把第二个参数当作没有查找到结果时的返回值，且不会抛出异常</div><div class="tb-code-line">const http = injector.get(Http, null)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>我们还可以通过 injector.get 方法的第三个参数，设置查询规则。</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} InjectFlags {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">// 设置跳过当前的容器查询</div><div class="tb-code-line">const http = injector.get(Http, null, InjectFlags.SkipSelf)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>InjectFlags 的查询规则如下：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">export enum InjectFlags {'{'}</div><div class="tb-code-line">&nbsp;&nbsp;/** 默认查找规则 */</div><div class="tb-code-line">&nbsp;&nbsp;Default = 'Default',</div><div class="tb-code-line">&nbsp;&nbsp;/** 锁定当前容器 */</div><div class="tb-code-line">&nbsp;&nbsp;Self = 'Self',</div><div class="tb-code-line">&nbsp;&nbsp;/** 跳过当前容器 */</div><div class="tb-code-line">&nbsp;&nbsp;SkipSelf = 'SkipSelf',</div><div class="tb-code-line">&nbsp;&nbsp;/** 可选查找 */</div><div class="tb-code-line">&nbsp;&nbsp;Optional = 'Optional'</div><div class="tb-code-line">{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<h2>容器作用域</h2>
<p>在异步场景中，如果我们不想异步的类提前在容器内声明，可以通过 scope 的方式异步提供到指定容器。</p>
<p>创建 scope</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} Scope {'}'} from '@tanbo/di';</div><div class="tb-code-line"><br/></div><div class="tb-code-line">export const scope = new Scope('myScope')</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// # parent-injector.ts 同步加载的文件</div><div class="tb-code-line">import {'{'} scope {'}'} from './my-scope'</div><div class="tb-code-line"><br/></div><div class="tb-code-line">export const parentInjector = new ReflectiveInjector(null, [/* 你的同步类 */], scope) // 声明当前容器为一个具名的的 scope</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>在异步文件中，添加 scope 声明：</p><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">import {'{'} scope {'}'} from './my-scope'</div><div class="tb-code-line"><br/></div><div class="tb-code-line">@Injectable({'{'}</div><div class="tb-code-line">&nbsp;&nbsp;provideIn: scope</div><div class="tb-code-line">{'}'})</div><div class="tb-code-line">export class Example {'{'}{'}'}</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre><pre lang="" theme="null" class="tb-pre"><div class="tb-pre-content"><div style="width:2.5em" class="tb-code-line-number-bg"></div><div class="tb-code-content"><div class="tb-code-line">// 异步加载的文件</div><div class="tb-code-line">import {'{'} scope {'}'} from './my-scope'</div><div class="tb-code-line">import {'{'} parentInjector {'}'} from './parent-injector'</div><div class="tb-code-line">import {'{'} Example {'}'} from './example'</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const asyncInjector = new ReflectiveInjector(parentInjector, [])</div><div class="tb-code-line"><br/></div><div class="tb-code-line">const example = asyncInjector.get(Example)</div><div class="tb-code-line"><br/></div></div><span class="tb-pre-lang"></span></div></pre>
<p>由于 Example 类的装饰器中，我们提供了 provideIn 的作用域声明。所以在异步的容器中，我们可以不在当前容器内再次声明。在调用异步容器的 get 方法时，会自动把 Example 类添加到声明了相同作用域的父容器内。 需要注意的是，查找还是按照就近原则，如果在当前容器到声明了 scope 的容器的注入器树之间提供了声明了相同的 provide，那么，你得到实例的将不是 scope 容器内的实例，而是最近的那一个。</p></div>
    )
  }
}